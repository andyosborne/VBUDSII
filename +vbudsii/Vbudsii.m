function [Results, p, g, L] = Vbudsii(p, g, varargin)
%
%VBUDSII/MAIN Run VBUDSII. This functiom must be in the root directory of
% VBUDS. The intended use of VBUDSII is to write a MATLAB script that defines
% p, g, adds VBUDSII's root directory to MATLAB's path, and then calls this
% function.
%
% INPUT
%   p           Parameter structure.
%   g           Geometry structure.
%
% OUTPUT
%   Results     Structure containing all results, including Region structure,
%               and the program's runtime.
%   p           Parameter structure. Should be the same as the input parameter
%               structure.
%   g           Geometry structure. Should not be the same as the input
%               parameter structure, as the Preprocessor module adds some
%               fields to the structure.
%   L           Cross section/data library containing data from ENDF/B and
%               processed by NJOY. The structure is initially created in the
%               MakeLibrary.m function. The script that calls VBUDSII may also
%               contain code that analyzes Results, and accordingly it may be
%               useful to have the Library available for that analysis.
%
% DEPENDENCIES
%   VBUDSII/PREPROCESSOR/PREPROCESSOR
%   VBUDSII/DATAPROCESSING/RESOLVEXS
%   VBUDSII/MULTICELL/MULTICELL
%   VBUDSII/DIFFUSION/DIFFUSION
%   VBUDSII/BATEMAN/BATEMAN
%   VBUDSII/POSTPROCESSOR/POSTPROCESSOR

% NOTES
%   This function is the backbone of VBUDSII. It calls a PREPROCESSOR that
%   initializes the runtime data structure Region and makes a cross section
%   structure L. Then, the function loops through each region, and calls
%   RESOLVEXS and MULTICELL for each region. Then, DIFFUSION provides
%   spatially-informed flux/power information across regions. Thus, DIFFUSION
%   is outside of the per-region loop. Then BATEMAN is called for each region.
%   After all the code is run, the POSTPROCESSOR plots various results.
%
% MAJOR REVISIONS
%   date        handle      description
%   20111030    cld2469     writing comments

import vbudsii.*

% Start timer.
tic;

% Determine the VBUDSII root directory in a platform-independent manner.
%mfilename('fullpath');
%disp('dbstack');
%S = dbstack('-completenames');
%vbudsiiroot = fileparts(S(1).file);
%p.vbudsiiDir = vbudsiiroot;
%clear S;

% Manage p.mode option. Each subsequent mode requires the previous mode.
% cellxs        generate cell-level macroscopic cross sections, corrected for
%               self-shielding if resolveXS == 1.
% spectrum      solve the Multicell spectral flux eigenvalue problem for the
%               infinite time-independent reactor.
% diffparam     obtain diffusion parameters, but do not solve diffusion
% diffusion     solve diffusion to obtain a spatial few-group flux for the
%               finite time-independent reactor.
% burnup        update composition of the reactor, outputting new atom
%               densities for the time steps specified, for the finite
%               time-dependent reactor.

% Initialize mode as spectrum.
modeidx = 2;
if isfield(p,'mode')
    if p.mode == 'cellxs'
        modeidx = 1;
    elseif p.mode == 'spectrum'
        modeidx = 2;
    elseif p.mode == 'diffparam'
        modeidx = 3;
    elseif p.mode == 'diffusion'
        modeidx = 4;
    elseif p.mode == 'burnup'
        modeidx = 5;
    end
end

% LOOK AT 11/04 MEETING NOTES: THERE SHOULD BE A FEW OTHER MODE OPTIONS HERE.

% Initialize runtime data structure Region, and call MAKELIBRARY.
%disp(p)
if(~isempty(varargin))
    [L, p, g, Region, fissionSpectrum] = Preprocessor(p,g,varargin{1});
else
    [L, p, g, Region, fissionSpectrum] = Preprocessor(p,g);
end

for timeidx = 1:p.nTimeSteps
    % For each burnup/time step.

    for regidx = 1:g.nRegions
        % For each region of the reactor.

        r = g.regionDef(regidx);

        % Prepare macroscopic cross sections, interpolate them, and converge on
        % appropriate values of S0.
        Region(regidx) = dataprocessing.ResolveXS(L, p, r, Region(regidx));

        if modeidx >= 2
            % Solve the matrix equation for flux, etc.
            Region(regidx) = multicell.Multicell(L, p, r, Region(regidx), ...
                fissionSpectrum);
        end

        Region(regidx) = dataprocessing.CollapseData(L, p, r, Region(regidx));

    end

    % Take spectral flux results from all regions, and using macroscopic
    % geometry information determine a few-group spatial flux.
    if modeidx >= 3
        % have diffusion parameters generated by a different function?
        diffusion.Diffusion(L, p, g, Region);
    end

    if modeidx == 5
        for regidx = 1:g.nRegions
            % Using reaction rates, update the material composition of the
            % reactor.
            Region(regidx) = bateman.Bateman(L, p, g.regionDef(regidx), ...
                Region(regidx));
        end
    end

end

% Take results and process them to provide human-digestible information.
Postprocessor(p, g, Region);

Results.runtime = toc;
fprintf('The runtime was: %.4f s\n', Results.runtime);

Results.Region = Region;

end

