classdef VbudsiiVsMcnpx < handle
    properties
        fdir;
        fname;
        figdir;
        geom;
        Lib;
        RV;
        RM;
        fid;
        fluxscale;
        doerror;
        ylog = true;
        lgdV =   {...
            'V (n,t)',...
            'V (n,s)',...
            'V (n,$\gamma$)',...
            'V (n,$\nu$f)'...
            };
        lgdM =  { ...
            'M (n,t)',...
            'M (n,e)',...
            'M (n,$\gamma$)',...
            'M (n,$\nu$f)',...
            };
        lgdzV = {...
            'V (n,t)',...
            'V (n,e)',...
            'V (n,$\gamma$)',...
            'V (n,f)', ...
            };
        lgdzM = { ...
            'M (n,t)',...
            'M (n,e)',...
            'M (n,$\gamma$)',...
            'M (n,f)'};
        %'MCNPX (n,i)',...
        MTstr = {...
            'total', ...
            'elastic scattering', ...
            'radiative capture', ...
            'fission', ...
        };
            %'total scattering', ...
            %'\nu-fission', ...
        ZAIDmap;
        cellmap  = {11          'h in h2o'; 
                    1001        'hydrogen-1';
                    8016        'oxygen-16';
                    11023       'sodium-23';
                    24052       'chromium-52';
                    26056       'iron-56';
                    28058       'nickel-58';
                    92235       'uranium-235';
                    92238       'uranium-238';
                    93235       'neptunium-235';
                    93236       'neptunium-236';
                    93237       'neptunium-237';  
                    93238       'neptunium-238';  
                    93239       'neptunium-239';  
                    94236       'plutonium-236'; 
                    94237       'plutonium-237';  
                    94238       'plutonium-238';  
                    94239       'plutonium-239';  
                    94240       'plutonium-240';  
                    94241       'plutonium-241';  
                    94242       'plutonium-242';  
                    94243       'plutonium-233';  
                    94244       'plutonium-234';  
                    94246       'plutonium-236';  
                    95241       'americium-241'; 
                    95242       'americium-242'; 
                    95243       'americium-243'; 
                    95244       'americium-244'; 
                    96241       'curium-241'; 
                    96242       'curium-242'; 
                    96243       'curium-243'; 
                    96244       'curium-244'; 
                    96245       'curium-245'; 
                    96246       'curium-246'; 
                    96247       'curium-247'; 
                    96248       'curium-248'; 
                    98249       'californium-249';  
                    40090       'zirconium-90';
                    40091       'zirconium-91'; 
                    40092       'zirconium-92'; 
                    40094       'zirconium-94'; 
                    40096       'zirconium-96'; 
                    39089       'yttrium-89'}
    end
    methods
        function self = VbudsiiVsMcnpx(fdir, fname, geom, Lib, ...
                ResultsV, ResultsM, fluxscale, varargin)
            self.ZAIDmap = containers.Map(self.cellmap(:,1), self.cellmap(:,2));
            self.fdir = fdir;
            self.fname = [fname];
            self.fid = 0;
            self.geom = geom;
            self.Lib = Lib;
            self.RV = ResultsV;
            self.RM = ResultsM;
            if length(varargin) == 1
                self.doerror = varargin{1};
            else
                self.doerror = false;
            end
            self.fluxscale = fluxscale;
            self.OpenFile();
            self.PrintPreamble();
            self.PrintFlux();
            self.PrintCrossSections();
            self.PrintEnd();
            self.Typeset();
        end
        function OpenFile(self)
            if ~isempty(self.fdir) && ~strcmp(self.fdir(end), filesep)
                self.fdir = [self.fdir filesep];
            end
            self.figdir = [self.fdir 'figs/'];
            
            if ~isempty(self.fdir) && ~exist(self.fdir, 'dir')
                system(['mkdir ' self.fdir]);
            end
            
            if ~exist(self.figdir, 'dir')
                system(['mkdir ' self.figdir]);
            end
            self.fid = fopen([self.fdir self.fname '.tex'], 'w');
        end
        function PrintPreamble(self)
            self.out('\\documentclass[letterpaper,12pt]{article}\n');
            self.out('\\usepackage{graphicx}\n');
            self.out('\\usepackage[left=.5in,right=.5in,top=.5in,bottom=.5in]{geometry}\n');
            self.out('\\usepackage{caption}\n');
            %self.out('\\newcommand{\\fitzefigtwo}[2]{\n');
            %self.out('\\begin{center}\\includegraphics{#1}\n');
            %self.out('\\captionof{figure}{#2}\\label{fig:#2}\\end{center}}\n');
            self.out('\\newcommand{\\fitzefigtwo}[2]{\n');
            self.out('\\includegraphics{#1}\n');
            self.out('}\n');
            self.out('\\begin{document}\n');
            self.out('\\title{Comparison between VBUDSII and MCNPX}\n');
            self.out('\\date{\\today}\n');
            self.out('\\maketitle\n');
            self.out('\\newpage\n');
            self.out('\\listoffigures\n');
            self.out('\\newpage\n');
        end
        function PrintEnd(self)
            self.out('\\end{document}\n');
            fclose(self.fid);
        end
        function Typeset(self)
            system(sprintf('rubber --pdf %s.tex', [self.fdir self.fname]));
            delete('*.aux');
            delete('*.log');
        end
        function Subsection(self, string)
            self.out(sprintf('%ssubsection{%s}\n', '\\', string));
        end
        function Section(self, string)
            self.out(sprintf('%ssection{%s}\n', '\\', string));
        end
        function PrintFlux(self)
            self.Section('Flux');
            regDef = self.geom.regionDef(1);
            vbudsiiflux = self.RV.Region(1).spectralFlux / ...
                sum(sum(self.RV.Region(1).spectralFlux)) * 100;
            mcnpxflux = self.RM.Region(1).spectralFlux / ...
                sum(sum(self.RM.Region(1).spectralFlux)) * 100;
            
            for iCell = 1:regDef.nCells
                fname = regexprep(regexprep(sprintf('fluxc%s', ...
                    regDef.cellDef(iCell).name), '\s', ''), ...
                    '\$', '');
                fname = regexprep(fname, '\$', '');
                printnuclearplot(fname, 'flux', {'V', ...
                    'M' ...
                    }, self.Lib.groupDef, ...
                    {vbudsiiflux(:,iCell)}, ...
                    'groupdefs2', self.Lib.groupDef, ...
                    'xss2', {mcnpxflux(:,iCell)}, ...
                    'fdir', self.figdir);
%                    'small', true);
                self.Fitzefig([self.figdir fname], ...
                    sprintf(['Spectral flux in cell %s ' ...
                    'between V and M'], regDef.cellDef(iCell).name));
                if self.doerror
                    error('no time');
                    printnuclearplot('fluxerror', 'errorflux', ...
                        {seriesv1, seriesv2}, ...
                        self.Lib.groupDef, ...
                        {vbudsiiflux(:,1)-mcnpxflux(:,1),...
                        vbudsiiflux(:,2)-mcnpxflux(:,2)}, ...
                        'fdir', self.figdir, 'ylog', false, ...
                        'small', true);
                    self.Fitzefig([self.figdir 'fluxerror'], ...
                        ['Spectral flux error in both the fuel and coolant ' ...
                        'between V and M.']);
                end
                self.out('\n\n');
            end
        end
        function PrintCrossSections(self)
            Lib = self.Lib;

            MTmap = {7 7;
                6 2;
                102 102;
                9 9};
            [nMT junk] = size(MTmap);
            % MT map for zaid-level cross sections.
            MTmapz = {7 7;
                6 2;
                %4 '4';
                102 102;
                18 18};
            [nMTz junk] = size(MTmapz);
            
            
            RegM = self.RM.Region(1);
            RegV = self.RV.Region(1);
            regDef = self.geom.regionDef(1);
            
            for iCell = 1:regDef.nCells
                self.Section(sprintf('Cross sections for the %s cell.', ...
                    regDef.cellDef(iCell).name));
                % cell-level cross section.
                %xsVbudsii = cell(1, nMT);
                %xsMcnpx = cell(1, nMT);
                %for iMT = 1:nMT
                %    if MTmap{iMT,1} == 6 % scattering kernel
                %        xsVbudsii{iMT} = ...
%sum(RegV.Cell(iCell).fine(Lib.MT(MTmap{iMT,1})).value)';
                %    else
                %        xsVbudsii{iMT} = ...
                %            RegV.Cell(iCell).fine(Lib.MT(MTmap{iMT,1})).value;
                %    end
                %    xsMcnpx{iMT} = ...
                %        RegM.Cell(iCell).fine(Lib.MT(MTmap{iMT,2})).value;
                %end
                %%self.AddCellXS(regDef.cellDef(iCell).name, xsVbudsii, xsMcnpx);
                %clear xsVbudsii xsMcnpx;
                
                % zaid-level cross section.
                for iZAID = 1:length(regDef.cellDef(iCell).initZAIDs)
                    ZAID = regDef.cellDef(iCell).initZAIDs(iZAID);
                    if ZAID == 222
                    else
                        self.out('\\newpage\n');
                        self.Subsection(...
                            sprintf('cell %s nuclide %s', ...
                            regDef.cellDef(iCell).name, ...
                            self.ZAIDmap(ZAID)));
                        self.out('\\begin{tabular}{cc}\n');
                        xszVbudsii = cell(1, nMTz);
                        xszMcnpx = cell(1, nMTz);
                        xszVbudsiiSlow = cell(1, nMTz);
                        xszVbudsiiShigh = cell(1, nMTz);
                        for iMT = 1:nMTz
                            if MTmap{iMT,1} == 6 % scattering kernel
                            xszVbudsii{iMT} = ...
sum(RegV.Cell(iCell).fine(Lib.MT(MTmapz{iMT,1})).z(iZAID).s)';
                            xszVbudsiiSlow{iMT} = ...
sum(RegV.Cell(iCell).fine(Lib.MT(2)).z(iZAID).t(:,:,1))';
                            xszVbudsiiShigh{iMT} = ...
sum(RegV.Cell(iCell).fine(Lib.MT(2)).z(iZAID).t(:,:,end))';
                            elseif MTmap{iMT,1} == 7
                            xszVbudsii{iMT} = ...
RegV.Cell(iCell).fine(Lib.MT(7)).z(iZAID).s -  ...
sum(RegV.Cell(iCell).fine(Lib.MT(2)).z(iZAID).s)' + ...
sum(RegV.Cell(iCell).fine(Lib.MT(6)).z(iZAID).s)';
                            xszVbudsiiSlow{iMT} = ...
RegV.Cell(iCell).fine(Lib.MT(7)).z(iZAID).t(:,1);
                            xszVbudsiiShigh{iMT} = ...
RegV.Cell(iCell).fine(Lib.MT(7)).z(iZAID).t(:,end);
                            else
                            xszVbudsii{iMT} = ...
RegV.Cell(iCell).fine(Lib.MT(MTmapz{iMT,1})).z(iZAID).s;
                            xszVbudsiiSlow{iMT} = ...
RegV.Cell(iCell).fine(Lib.MT(MTmapz{iMT,1})).z(iZAID).t(:,1);
                            xszVbudsiiShigh{iMT} = ...
RegV.Cell(iCell).fine(Lib.MT(MTmapz{iMT,1})).z(iZAID).t(:,end);
                            end
                            xszMcnpx{iMT} = ...
RegM.Cell(iCell).fine(Lib.MT(MTmapz{iMT,2})).z(iZAID).s;
                            % Create per-MT plots.
                            self.AddMTXS(regDef.cellDef(iCell).name, ...
                                regDef.cellDef(iCell).initZAIDs(iZAID), iMT, ...
                                xszVbudsii{iMT}, xszMcnpx{iMT}, ...
                                xszVbudsiiSlow{iMT}, xszVbudsiiShigh{iMT}, ...
                                mean(RegV.Cell(iCell).S0s(:,iZAID)));
                            if iMT == 1 || iMT == 3
                                self.out(' & ');
                            else iMT == 2
                                self.out(' \\\\ \n');
                            end
                        end
                        self.out('\\end{tabular}\n');
                        
                    %self.AddZAIDXS(regDef.cellDef(iCell).name, ...
                    %    regDef.cellDef(iCell).initZAIDs(iZAID), ...
                    %    xszVbudsii, xszMcnpx, ...
                    %    mean(RegV.Cell(iCell).S0s(:,iZAID)));
                    clear xszVbudsii xszMcnpx xszVbudsiiSlow ...
                        xszVbudsiiShigh;
                    end
                end
            end
        end
        function AddMTXS(self, cellname, ZAID, iMT, xszVbudsii, xszMcnpx, ...
                xszVbudsiiSlow, xszVbudsiiShigh, avgS0)
            fname = regexprep(sprintf('xs%sz%im%i', cellname, ZAID, iMT), ...
                    '\$', '');
            printnuclearplot(regexprep(fname, '\s', ''), 'micro', ...
                {self.lgdzV{iMT}, ...
                [self.lgdzV{iMT} ' S0 = -1'], [self.lgdzV{iMT} ' S0 = 10'],...
                self.lgdzM{iMT}, ...
                }, ...
                self.Lib.groupDef, ...
                {xszVbudsii, xszVbudsiiSlow, xszVbudsiiShigh}, ...
                'groupdefs2', self.Lib.groupDef, ...
                'xss2', {xszMcnpx}, 'ylog', self.ylog, ...
                'fdir', self.figdir, ...
                'xbelow',sprintf('mean S0: %f', avgS0), ...
                'small', true, ...
                'legendOn', false);
            self.Fitzefig(regexprep([self.figdir fname], '\s', ''), ...
                sprintf(['%s, ' ...
                    'nuclide %s, cell %s.'], self.MTstr{iMT}, ...
                    self.ZAIDmap(ZAID), cellname));
            if self.doerror
                printnuclearplot(regexprep([fname 'error'], '\s', ''), 'errormicro', ...
                    {'error'}, ...
                    self.Lib.groupDef, ...
                    {xszVbudsii-xszMcnpx}, ...
                    'fdir', self.figdir, 'ylog', true, ...
                    'small', true);
                self.Fitzefig(regexprep([self.figdir fname 'error'], '\s', ''), ...
                sprintf(['%s, ' ...
                    '%s, cell %s'], self.MTstr{iMT}, ...
                    self.ZAIDmap(ZAID), cellname));
            end
        end
        function AddCellXS(self, cellname, xsVbudsii, xsMcnpx)
            fname = regexprep(sprintf('xs%s', cellname), ...
                '\$', '');
            printnuclearplot(regexprep(fname, '\s', ''), ...
                'macro', [self.lgdV, self.lgdM], ...
                self.Lib.groupDef, ...
                xsVbudsii, ...
                'groupdefs2', self.Lib.groupDef, ...
                'xss2', xsMcnpx, 'ylog', self.ylog, ...
                'fdir', self.figdir, ...
                'small', true);
            self.Fitzefig(regexprep([self.figdir fname], '\s', ''), ...
                sprintf(['macroscopic cell-level ' ...
                    'cross sections for the ' ...
                    '%s cell.'], cellname));
        end
        function AddZAIDXS(self, cellname, ZAID, xszVbudsii, xszMcnpx, avgS0)
            fname = regexprep(sprintf('xs%sz%i', cellname, ZAID), ...
                '\$', '');
            printnuclearplot(regexprep(fname, '\s', ''), ...
                'micro', [self.lgdzV, self.lgdzM], ...
                self.Lib.groupDef, ...
                xszVbudsii, ...
                'groupdefs2', self.Lib.groupDef, ...
                'xss2', xszMcnpx, 'ylog', self.ylog, ...
                'fdir', self.figdir, ...
                'xbelow',sprintf('mean S0: %f', avgS0), ...
                'small', true);
            self.Fitzefig(regexprep([self.figdir fname], '\s', ''), ...
                sprintf(['nuclide %s in ' ...
                    'the %s cell.'], self.ZAIDmap(ZAID), cellname));
        end
        function Fitzefig(self, filename, caption)
            self.out(sprintf('%sfitzefigtwo{%s}{%s}\n', '\\', ...
                filename, caption));
        end
        function out(self, string)
            fprintf(self.fid, string);
        end
    end
end
